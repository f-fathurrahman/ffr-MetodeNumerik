\section{Metode Euler}

Metode Euler: menggunakan turunan pertama sebagai estimasi kemiringan pada
$x_i$:
\begin{equation*}
\phi = f(x_i, y_i)
\end{equation*}
sehingga diperoleh:
\begin{equation}
y_{i+1} = y_{i} + f(x_i, y_i) h
\label{eq:euler_1step}
\end{equation}


\begin{soal}[Chapra Contoh 25.1]
Gunakan metode Euler untuk menyelesaikan persamaan diferensial berikut:
\begin{equation*}
\frac{\mathrm{d}y}{\mathrm{d}x} = -2x^3 + 12x^2 - 20x + 8.5
\end{equation*}
dari $x=0$ sampai $x=4$ dengan ukuran langkah 0.5.
Syarat awal adalah $y(x=0) = 1$.
Bandingkan dengan solusi eksak:
\begin{equation*}
y(x) = -0.5x^4 + 4x^3 - 10x^2 + 8.5x + 1
\end{equation*}
\end{soal}

Implementasi Python, versi manual:
\begin{pythoncode}
# initial cond
x0 = 0.0
y0 = 1.0

# Using step of 0.5, starting from x0 and y0
x = x0
y = y0
h = 0.5
xp1 = x + h # we are searching for solution at x = 0.5
ϕ = -2*x**3 + 12*x**2 - 20*x + 8.5
yp1 = y + ϕ*h
y_true = -0.5*xp1**4 + 4*xp1**3 - 10*xp1**2 + 8.5*xp1 + 1
ε_t = (y_true - yp1)/y_true * 100
print("First step : x = %f y_true = %.5f y = %.5f ε_t = %.1f %%" % (xp1, y_true, yp1, ε_t))

# Second step
x = xp1 # x from the previous step
y = yp1 # y from the previoud step
h = 0.5
xp1 = x + h # we are searching for solution at x = 1.0
ϕ = -2*x**3 + 12*x**2 - 20*x + 8.5
yp1 = y + ϕ*h
y_true = -0.5*xp1**4 + 4*xp1**3 - 10*xp1**2 + 8.5*xp1 + 1
ε_t = (y_true - yp1)/y_true * 100
print("Second step: x = %f y_true = %.5f y = %.5f ε_t = %.1f %%" % (xp1, y_true, yp1, ε_t))
\end{pythoncode}

Contoh keluaran:
\begin{textcode}
First step : x = 0.500000 y_true = 3.21875 y = 5.25000 ε_t = -63.1 %
Second step: x = 1.000000 y_true = 3.00000 y = 5.87500 ε_t = -95.8 %
\end{textcode}


Karena skema metode Euler yang diberikan pada Persamaan \eqref{eq:euler_1step}
akan digunakan berulang kali, maka sebaiknya skema ini diimplementasikan dalam
suatu fungsi.
\begin{pythoncode}
# One-step aplication of Euler's method for ODE
def ode_euler_1step(dfunc, xi, yi, h):
    return yi + dfunc(xi,yi)*h
\end{pythoncode}

Kode program:
\begin{pythoncode}
# ... Tambahkan atau import fungsi-fungsi yang diperlukan

# the left hand side of dy/dx=... (in general depends on x and y)
# In the present case it only depends on x
def deriv(x, y):
    return -2*x**3 + 12*x**2 - 20*x + 8.5

def exact_sol(x):
    return -0.5*x**4 + 4*x**3 - 10*x**2 + 8.5*x + 1

# initial cond
x0 = 0.0
y0 = 1.0

# Using step of 0.5, starting from x0 and y0
x = x0
y = y0
h = 0.5
xp1 = x + h # we are searching for solution at x = 0.5
yp1 = ode_euler_1step(deriv, x, y, h)
y_true = exact_sol(xp1)
ε_t = (y_true - yp1)/y_true * 100
print("First step : x = %f y_true = %.5f y = %.5f ε_t = %.1f %%" % (xp1, y_true, yp1, ε_t))

# Second step
x = xp1 # x from the previous step
y = yp1 # y from the previoud step
h = 0.5
xp1 = x + h # we are searching for solution at x = 1.0
yp1 = ode_euler_1step(deriv, x, y, h)
y_true = exact_sol(xp1)
ε_t = (y_true - yp1)/y_true * 100
print("Second step: x = %f y_true = %.5f y = %.5f ε_t = %.1f %%" % (xp1, y_true, yp1, ε_t))
\end{pythoncode}
Keluaran yang diperoleh seharusnya sama dengan cara manual (tanpa fungsi).


\subsection*{Analisis kesalahan metode Euler}

Kesalahan pada metode Euler:
\begin{itemize}
\item Kesalahan pemotongan (truncation)
\item Kesalahan pembulatan (round-off)
\end{itemize}

Kesalahan pemotongan terdiri dari dua bagian:
\begin{itemize}
\item kesalahan pemotongan lokal yang berasal dari aplikasi metode pada satu
ukuran langkah.
\item kesalahan pemotongan perambatan (propagated truncation error) yang diakibatkan
aproksimasi pada langkah-langkah sebelumnya.
\end{itemize}
Penjumlahan dari kedua jenis kesalahan tersebut adalah kesalahan pemotongan global.

Misalkan, persamaan diferensial yang akan diintegralkan adalah:
\begin{equation*}
y' = \frac{\mathrm{d}y}{\mathrm{d}x} = f(x,y)
\end{equation*}
Jika solusi, yaitu fungsi yang mendeskripsikan $y$, memiliki turunan yang kontinu, maka
deret Taylor dapat digunakan untuk merepresentasikan fungsi di sekitar nilai awal
$(x_i, y_i)$:
\begin{equation*}
y_{i+1} = y_{i} + y'_{i} h + \frac{y''_{i}}{2!}h^2 + \cdots + \frac{y^{(n)}_{i}}{n!} h^n + R_n
\end{equation*}
dengan $h = x_{i+1} - x_{i}$ dan $R_n$ adalah suku sisa yang didefinisikan sebagai:
\begin{equation*}
R_n = \frac{y^{n+1}(\xi)}{(n+1)!} h^{n+1}
\end{equation*}
di mana $\xi$ berada di dalam interval $[x_i, x_{i+1}]$.
Alternatif penulisan:
\begin{equation*}
y_{i+1} = y_{i} + f(x_i, y_i) h + \frac{f'(x_i, y_i)}{2!}h^2 + \cdots +
\frac{f^{(n-1)}(x_i, y_i)}{n!} h^n + \mathcal{O}(h^{n+1})
\end{equation*}
di mana $\mathcal{O}(h^{n+1})$ menyatakan kontribusi kesalahan pemotongan lokal
yang sebanding dengan ukuran langkah pangkat $(n+1)$.

Dengan membandingkan persamaan ini dengan skema metode Euler, diperoleh
kesalahan pemotongan pada metode Euler sebagai berikut:
\begin{equation*}
E_{t} = \frac{f'(x_i, y_i)}{2!} h^2 + \cdots + \mathcal{O}(h^{n+1})
\end{equation*}
untuk nilai $h$ yang cukup kecil, dapat digunakan hanya satu suku saja:
\begin{equation*}
E_{a} = \frac{f'(x_i, y_i)}{2!} h^2
\end{equation*}
atau
\begin{equation*}
E_a = \mathcal{O}(h^2)
\end{equation*}
di mana $E_a$ adalah aproksimasi kesalahan pemotongan lokal.

Dengan loop, perhitungan error pemotongan
\begin{pythoncode}
# .... definisi deriv
# .... definisi ode_euler_1step
# .... definisi exact_sol

# For local truncation errors
from math import factorial
def trunc_err_second(x,y,h):
    return (-6*x**2 + 24*x - 20)*h**2/factorial(2)

def trunc_err_third(x,y,h):
    return (-12*x + 24)*h**3/factorial(3)

def trunc_err_fourth(x,y,h):
    return -12*h**4/factorial(4)

# initial cond
x0 = 0.0
y0 = 1.0

print("   x     y_true   y_Euler       ε_t   ε_t local")
print("-----------------------------------------------")

print("%5.1f  %8.5f  %8.5f" % (x0, y0, y0)) # Initial cond

x = x0
y = y0
h = 0.5
for i in range(0,8):
    xp1 = x + h
    yp1 = ode_euler_1step(deriv, x, y, h)
    y_true = exact_sol(xp1)
    ε_t = (y_true - yp1)/y_true * 100
    ε_t_local = (trunc_err_second(x,y,h) + trunc_err_third(x,y,h) + \
        trunc_err_fourth(x,y,h))/y_true * 100
    print("%5.1f  %8.5f  %8.5f  %8.1f%%  %8.1f%%" % (xp1, y_true, yp1, ε_t, ε_t_local))
    # Update x and y for the next step
    x = xp1
    y = yp1
\end{pythoncode}

Contoh keluaran:
\begin{textcode}
   x     y_true   y_Euler       ε_t   ε_t local
-----------------------------------------------
  0.0   1.00000   1.00000
  0.5   3.21875   5.25000     -63.1%     -63.1%
  1.0   3.00000   5.87500     -95.8%     -28.1%
  1.5   2.21875   5.12500    -131.0%      -1.4%
  2.0   2.00000   4.50000    -125.0%      20.3%
  2.5   2.71875   4.75000     -74.7%      17.2%
  3.0   4.00000   5.87500     -46.9%       3.9%
  3.5   4.71875   7.12500     -51.0%     -11.3%
  4.0   3.00000   7.00000    -133.3%     -53.1%
\end{textcode}
    




Chapra Contoh 25.3

\begin{pythoncode}
def ode_euler(dfunc, x0, y0, h, Nstep):
    x = np.zeros(Nstep+1)
    y = np.zeros(Nstep+1)
    # Start with initial cond
    x[0] = x0
    y[0] = y0
    for i in range(0,Nstep):
        x[i+1] = x[i] + h
        y[i+1] = ode_euler_1step(dfunc, x[i], y[i], h)
    return x, y
\end{pythoncode}

Kode program
\begin{pythoncode}
# .... Definisi dan/atau import fungsi-fungsi yang diperlukan

# initial cond
x0 = 0.0
y0 = 1.0
xf = 4.0

# Using h=0.5
h = 0.5
Nstep = int(xf/h)
xs1, ys1 = ode_euler(deriv, x0, y0, h, Nstep)

# Using h=0.25
h = 0.25
Nstep = int(xf/h)
xs2, ys2 = ode_euler(deriv, x0, y0, h, Nstep)

# True solution
x_true = np.linspace(0.0, 4.0, 200)
y_true = exact_sol(x_true)

# Plot
plt.clf()
plt.plot(xs1, ys1, label="h=0.5", marker="o")
plt.plot(xs2, ys2, label="h=0.5", marker="o")
plt.plot(x_true, y_true, label="true") # Do not show the markers
plt.legend()
plt.tight_layout()
plt.savefig("IMG_example_25_3.png", dpi=150)
plt.savefig("IMG_example_25_3.pdf")
\end{pythoncode}

\begin{figure}[h]
{\centering
\includegraphics[scale=0.7]{../../chapra_7th/ch25/IMG_chapra_example_25_3.pdf}
\par}
\end{figure}

