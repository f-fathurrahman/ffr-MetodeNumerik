import numpy as np

def MullerBrown_energy(x, y):

    p1 = [-200.0, -1.0,  0.0, -10.0,  1.0, 0.0]
    p2 = [-100.0, -1.0,  0.0, -10.0,  0.0, 0.5]
    p3 = [-170.0, -6.5, 11.0,  -6.5, -0.5, 1.5]
    p4 = [15.0,  0.7,  0.6,   0.7, -1.0, 1.0]
    
    # Energies
    z1 = p1[0] * np.exp((p1[1]*(x - p1[4])**2) + (p1[2]*(x - p1[4])*(y - p1[5])) + (p1[3]*(y - p1[5])**2))
    z2 = p2[0] * np.exp((p2[1]*(x - p2[4])**2) + (p2[2]*(x - p2[4])*(y - p2[5])) + (p2[3]*(y - p2[5])**2))
    z3 = p3[0] * np.exp((p3[1]*(x - p3[4])**2) + (p3[2]*(x - p3[4])*(y - p3[5])) + (p3[3]*(y - p3[5])**2))
    z4 = p4[0] * np.exp((p4[1]*(x - p4[4])**2) + (p4[2]*(x - p4[4])*(y - p4[5])) + (p4[3]*(y - p4[5])**2))

    energy = (z1 + z2 + z3 + z4)/100

    return energy


# FIXME: combine into one function only

def MullerBrown_forces(x, y):

    p1 = [-200.0, -1.0,  0.0, -10.0,  1.0, 0.0]
    p2 = [-100.0, -1.0,  0.0, -10.0,  0.0, 0.5]
    p3 = [-170.0, -6.5, 11.0,  -6.5, -0.5, 1.5]
    p4 = [15.0,  0.7,  0.6,   0.7, -1.0, 1.0]

    z1 = p1[0] * np.exp((p1[1]*(x - p1[4])**2) + (p1[2]*(x - p1[4])*(y - p1[5])) + (p1[3]*(y - p1[5])**2))
    z2 = p2[0] * np.exp((p2[1]*(x - p2[4])**2) + (p2[2]*(x - p2[4])*(y - p2[5])) + (p2[3]*(y - p2[5])**2))
    z3 = p3[0] * np.exp((p3[1]*(x - p3[4])**2) + (p3[2]*(x - p3[4])*(y - p3[5])) + (p3[3]*(y - p3[5])**2))
    z4 = p4[0] * np.exp((p4[1]*(x - p4[4])**2) + (p4[2]*(x - p4[4])*(y - p4[5])) + (p4[3]*(y - p4[5])**2))

    dx1 = z1 * (2*p1[1]*(x-p1[4])+p1[2]*(y-p1[5]))
    
    dx2 = z2 * (2*p2[1]*(x-p2[4])+p2[2]*(y-p2[5]))

    dx3 = z3 * (2*p3[1]*(x-p3[4])+p3[2]*(y-p3[5]))

    dx4 = z4 * (2*p4[1]*(x-p4[4])+p4[2]*(y-p4[5]))

    dy1 = z1 * (p1[2]*(x-p1[4])+2*p1[3]*(y-p1[5]))

    dy2 = z2 * (p2[2]*(x-p2[4])+2*p2[3]*(y-p2[5]))

    dy3 = z3 * (p3[2]*(x-p3[4])+2*p3[3]*(y-p3[5]))

    dy4 = z4 * (p4[2]*(x-p4[4])+2*p4[3]*(y-p4[5]))

    Fx = dx1 + dx2 + dx3 + dx4
    Fy = dy1 + dy2 + dy3 + dy4

    return -Fx/100, -Fy/100
