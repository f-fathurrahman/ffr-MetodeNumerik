\section{Chapra Contoh 4.8}
Diketahui sebuah fungsi:
\begin{equation}
f(x) = -0.1x^4 - 0.15x^3 - 0.5x^2 - 0.25x + 1.2
\end{equation}
Turunan pertama dari $f(x)$ adalah:
\begin{equation}
f'(x) = -0.4x^3 - 0.45x^2 - x - 0.25
\end{equation}
Kita akan menghitung pendekatan fungsi ini pada $x=0.5$ dengan menggunakan
formula beda hingga tengah. Kita akan mulai dari $h=1$, kemudian secara bertahap
memperkecil nilai $h$ dengan faktor 10 untuk mempelajari bagaimana
pengaruh nilai $h$ terhadap kesalahan.

\begin{soal}
Berikut ini adalah program yang dapat Anda lengkapi (versi \textit{single precision}).
\begin{pythoncode}
import numpy as np

def f(x):
  return -np.float32(0.1)*x**np.float32(4) - np.float32(0.15)*x**np.float32(3) - \
  np.float32(0.5)*x**np.float32(2) - np.float32(0.25)*x + np.float32(1.2)
  
def df(x):
  return -np.float32(0.4)*x**np.float32(3) - np.float32(0.45)*x**np.float32(2) - \
  x - np.float32(0.25)
  
def centered_diff(f, x, h):
  return ( .... )/(np.float32(2)*h) # isi titik-titik
  
  x = np.float32(0.5)
  h = np.float32(1.0)
  true_val = ! ... lengkapi
  
  print("--------------------------------------------------------")
  print("           h             approx_val             error")
  print("--------------------------------------------------------")
  
for i in range(11):
  approx_val = # ... lengkapi
  εt = abs(approx_val - true_val)
  print("%18.10f %18.14f %18.13f" % (h, approx_val, εt))
  h = h/np.float32(10)

print(type(h))
print(type(centered_diff(f,x,h)))  
\end{pythoncode}
Coba juga untuk versi \textit{double precision} (default pada NumPy
atau \txtinline{np.float64}).
Apakah error yang Anda peroleh semakin mendekati nol apabila nilai $h$ semakin
diperkecil?
NumPy juga menyediakan tipe bilangan \textit{quadruple precision}, yang lebih
\textit{precise} dari \textit{double precision}, yaitu
\txtinline{np.float128}. Coba ulangi perhitungan dan analisis Anda dengan
menggunakan \txtinline{np.float128}.
Berikan penjelasan mengenai hasil yang Anda dapatkan.
\end{soal}