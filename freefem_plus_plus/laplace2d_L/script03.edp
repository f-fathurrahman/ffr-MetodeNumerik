// Correct L-shaped domain definition

// Define borders of a proper L-shaped domain ([-1,1]×[-1,1] without [0,1]×[0,-1])
border bottom(t=-1, 1){x=t; y=-1; label=1;};    // Bottom edge (full width)
border right(t=-1, 1){x=1; y=t; label=2;};     // Right edge (full height)
border top(t=1, 0){x=t; y=1; label=3;};       // Top edge (full width)
border left1(t=1, 0){x=-1; y=t; label=4;};     // Left upper part
border left2(t=0, -1){x=-1; y=t; label=5;};   // Left lower part
border cut(t=0, -1){x=0; y=t; label=6;};      // Vertical cut (inner edge)
border inner(t=-1, 0){x=t; y=0; label=7;};    // Horizontal cut (inner edge)

plot( bottom(20) + right(20) + top(20),
    wait=true, cmm = "Just the border lines", fill=false);


//plot( bottom(20) + right(20) + top(20) + left1(20) + left2(20) + cut(20) + inner(20),
//    wait=true, cmm = "Just the border lines", fill=false);


// Create mesh - note we subtract the inner parts to make the L-shape
//mesh Th = buildmesh(bottom(40) + right(40) + top(40) + left1(20) + left2(20) 
//          + cut(20) + inner(20));

// Plot the mesh
//plot(Th, wait=true, cmm="Proper L-shaped mesh");

// Finite element space
//fespace Vh(Th, P1);
//Vh u, v;
//
//// Boundary conditions
//real alpha = 1.0;
//func dirichletBC = sin(pi*x)*cos(pi*y);
//func neumannBC = x + y;
//func sourceTerm = 0;
//
//// Variational problem
//problem Laplace(u, v, solver=LU)
//    = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
//    - int2d(Th)(sourceTerm*v)
//    - int1d(Th, 2)(neumannBC*v)
//    + int1d(Th, 4)(alpha*u*v)
//    + on(1, 3, 5, u=dirichletBC);
//
//// Solve and plot
//Laplace;
//plot(u, fill=true, value=true, wait=true, cmm="Solution on L-shape");

// Optional: Save mesh and solution for external visualization
//savemesh(Th, "Lshape.msh");
//ofstream file("Lshape_solution.txt");
//file << u[];