% 2D FDTD simulator: Scattering off a PEC cylinder. 
% A split-field PML is used as numerical absorber.
% The same update equations are used in the entire computational domain 
%
% Author: DBDdavidson Nov 2003. 
% Usage: fdtd_2D_pml_demo
% Known issues: the movie generated by this code is not running correctly
% under MATLAB R2009a.

% Confirm run
disp('Run simulation and overwrite existing results? Break  - control-c - to stop, any other key to run...')
pause


clear;
format compact;
% Selectively includes PEC cylinder, centered at (N_centre_x,N_centre_y)
cyl_present=input('Include PEC cylinder? (1: true; 0: false)')
if not(cyl_present) 
  line_source=input('Include line source? (1: true; 0: false)')
else
  line_source=false
end;

% Physical constants

c = 2.997925e8;    % [m/s] Speed of light in vacuum
eps_0 = 8.854e-12; % [F/m] epsilon_0
mu_0 = 4*pi*1e-7;  % [H/m] mu_0
eta_0 = sqrt(mu_0/eps_0);
% [Ohm] Wave impedance of free space
% Set parameters for simulation

refine = input('Factor to refine mesh by? 1 standard')    % A quick method to refine the mesh 
pulse_compress = 1 % A quick way to shorten the pulse

%N_x = refine*400     % number of cells in x-direction
N_x = refine*200      % number of cells in x-direction
N_y = refine*200      % ditto y
M = refine*350        % Number of time steps
L = round(N_x/2)      % scat/tot field boundary
if line_source  
   delta_s = 0.005       % Mesh size UNCHANGED for PML tests.   
else
   delta_s = 0.005/refine % [m] spatial step
end
R = 1        % fraction of Courant limit. Must be <= 1
delta_t = R* delta_s/(c * sqrt(2)) 
% [s] Time step size
sigma = 1.0e-10/pulse_compress
% Controls spectral content of Gaussian derivative pulse - 
% equals 1/omega_max
f_max = (1/sigma)/(2*pi) % Freq of largest significant spectral component, in Hz. Information only
m_offset = 4*sigma;  % Controls switch-on time
Peak = 1;      % Peak amplitude of E field
% Set parameters for PEC cylinder
radius = 0.03 % [m] radius of cylinder
N_centre_x = round(0.75*N_x)
N_centre_y = round(0.5*N_y)

% Check that the simulation specification is valid:

if ((N_centre_x-L)*delta_s <= radius)
    disp('Error in simulation data. Scattered/total field not entirely to the left of target')
    return
end

%------------------------------------------

% Set up material grid (free space to start)
sigma_x = zeros(N_x,N_y);
sigma_y = zeros(N_x,N_y);
sigma_ast_x = zeros(N_x,N_y);
sigma_ast_y = zeros(N_x,N_y);

% Set up PML
poly_m = 3;
sigma_max = 0.8*(poly_m+1)/(eta_0*delta_s);
d_cell = 10;
% First, for y-absorption.
for jj = 1:d_cell
    dist = d_cell-(jj-1);
    sigma_y(:,jj) = sigma_max*(dist/d_cell)^poly_m;
    sigma_y(:,N_y-jj+1) = sigma_y(:,jj);
end
% DON'T use sigma_ast_y = sigma_y * eta_0^2; % THIS ISN'T CORRECT DUE TO DELTA/2 OFFSET!
for jj = 1:d_cell
    dist = d_cell-(jj-1)-0.5; % Hz field components located delta/2 away.
    sigma_ast_y(:,jj) = eta_0^2*sigma_max*(dist/d_cell)^poly_m;
    sigma_ast_y(:,N_y-jj) = sigma_ast_y(:,jj);
end
% Then, for x-absorption. Corner regions are automatically overlapped.
for ii = 1:d_cell
    dist = d_cell-(ii-1);
    sigma_x(ii,:) = sigma_max*(dist/d_cell)^poly_m;
    sigma_x(N_x-ii+1,:) = sigma_x(ii,:);
end
for ii = 1:d_cell
    dist = d_cell-(ii-1)-0.5; % Hz field components located delta/2 away.
    sigma_ast_x(ii,:) = eta_0^2*sigma_max*(dist/d_cell)^poly_m;
    sigma_ast_x(N_x-ii,:) = sigma_ast_x(ii,:);
end

C_aEx = (1-sigma_y*delta_t/(2*eps_0))./(1+sigma_y*delta_t/(2*eps_0)); 
C_bEx = delta_t/(eps_0*delta_s)./(1+sigma_y*delta_t/(2*eps_0));
C_aEy = (1-sigma_x*delta_t/(2*eps_0))./(1+sigma_x*delta_t/(2*eps_0)); 
C_bEy = delta_t/(eps_0*delta_s)./(1+sigma_x*delta_t/(2*eps_0));
D_aHzx = (1-sigma_ast_x*delta_t/(2*mu_0))./(1+sigma_ast_x*delta_t/(2*mu_0)); 
D_bHzx = delta_t/(mu_0*delta_s)./(1+sigma_ast_x*delta_t/(2*mu_0));
D_aHzy = (1-sigma_ast_y*delta_t/(2*mu_0))./(1+sigma_ast_y*delta_t/(2*mu_0)); 
D_bHzy = delta_t/(mu_0*delta_s)./(1+sigma_ast_y*delta_t/(2*mu_0));
% Now force the electric fields to zero inside (and on the surface of) the PEC
% Note that the indices of the centre are treated as per usual FDTD
% indices, i.e. the actual location is:
%x_c=(N_centre_x-1))*delta_s ; y_c=(N_centre_x-1))*delta_s
if cyl_present % Otherwise just leave it as free space
    for ii = 1:N_x
        for jj = 1:N_y
            if ( sqrt( ((ii-1/2-(N_centre_x-1))*delta_s)^2 +  ((jj-1-(N_centre_y-1))*delta_s)^2 ) <=  radius ) 
                C_bEx(ii,jj) = 0;
            end
            if ( sqrt( ((ii-1-(N_centre_x-1))*delta_s)^2 +  ((jj-1/2-(N_centre_y-1))*delta_s)^2 ) <=  radius ) 
                C_bEy(ii,jj) = 0;
            end
        end
    end
end 
%------------------------------------------

% Set up storage for time histories.
H_z_point1 = zeros(1,M);
E_y_point1 = zeros(1,M);
% point1_x = round(3*N_x/4);
if refine == 1 
   point1_x = 190 % For PML tests - to get same x position in different meshes
elseif refine == 2
   point1_x = 290
else 
   disp('Incorrect refine factor for PML tests')
   pause;
end
point1_y = round(N_y/2);
H_z_point2 = zeros(1,M);
E_y_point2 = zeros(1,M);
point2_x = round((N_x+L)/2);
point2_y = round(N_y/2);


% Produce a simple graphical output, showing the cylinder, scat/tot zone
% interface and the point at which the scattered field will be computed. 
mesh_pic=zeros(N_x,N_y);
for ii = 1:N_x
    for jj = 1:N_y
        if C_bEx(ii,jj) == 0
            mesh_pic(ii,jj) = N_x/2; % To get vertical scale in plot OK when plotted
        elseif ii==L
            mesh_pic(ii,jj) = N_x/4;
        elseif (ii==point1_x & jj==point1_y)
            mesh_pic(ii,jj) = N_x/2;
        end
    end 
end
mesh((1:1:N_y),(1:1:N_x),mesh_pic);
axis image;
title('Simulation region')
disp('Press - almost - any key to continue')
pause;


% First time step - Initialize values for H_z, E_x and E_y
H_zx_nmin1 = zeros(N_x,N_y); %
H_zy_nmin1 = zeros(N_x,N_y); %
E_x_nmin1 = zeros(N_x,N_y); %
E_y_nmin1 = zeros(N_x,N_y); %
% Pre-allocation
H_zx_n = zeros(N_x,N_y); %
H_zy_n = zeros(N_x,N_y); %
H_z_n = zeros(N_x,N_y); %
E_x_n = zeros(N_x,N_y); %
E_y_n = zeros(N_x,N_y); %
% Get CPU time
start_time=cputime;
%------------------------------------------

movie_count = 1;
movie_interval = round(refine*50),
 
report_time_interval = 50; 


% Time loop
for m = 2:M,
    
    % Update H fields: 
    H_zx_n(1:N_x-1,1:N_y-1) = D_aHzx(1:N_x-1,1:N_y-1).*H_zx_nmin1(1:N_x-1,1:N_y-1) ...
        - D_bHzx(1:N_x-1,1:N_y-1).*(  E_y_nmin1(2:N_x,1:N_y-1) - E_y_nmin1(1:N_x-1,1:N_y-1)  ) ;
    H_zy_n(1:N_x-1,1:N_y-1) = D_aHzy(1:N_x-1,1:N_y-1).*H_zy_nmin1(1:N_x-1,1:N_y-1) ...
        + D_bHzy(1:N_x-1,1:N_y-1).*(  E_x_nmin1(1:N_x-1,2:N_y)   - E_x_nmin1(1:N_x-1,1:N_y-1)  ) ;
    if line_source 
        % Drive a test line hard source - used to check basic operation
        H_z_n = H_zx_n+H_zy_n;
        H_z_n(N_x/2,N_y/2) = gaussder_norm((m-1)*delta_t,m_offset,sigma);
    else % Special update on scat/tot field boundary
        E_y_nmin1_inc = ones(1,N_y)*Peak*gaussder_norm((m-1)*delta_t - (L-1)*delta_s/c,m_offset,sigma) ;
        H_zx_n(L,1:N_y-1) = D_aHzx(L,1:N_y-1).*H_zx_nmin1(L,1:N_y-1) ...
            - D_bHzx(L,1:N_y-1).*(  E_x_nmin1(L,2:N_y)     - E_x_nmin1(L,1:N_y-1) ) ; % WRONG E FIELD!
        H_zy_n(L,1:N_y-1) = D_aHzy(L,1:N_y-1).*H_zy_nmin1(L,1:N_y-1) ...
            + D_bHzy(L,1:N_y-1).*(  E_y_nmin1(L+1,1:N_y-1) - E_y_nmin1(L,1:N_y-1) - E_y_nmin1_inc(1:N_y-1) ) ; % DITTO!
        H_z_n = H_zx_n+H_zy_n;
    end
    % Update E fields: note that latest H fields must be used.
   
    E_x_n(2:N_x,2:N_y) = C_aEx(2:N_x,2:N_y).*E_x_nmin1(2:N_x,2:N_y) ...
        + C_bEx(2:N_x,2:N_y).*(  H_z_n(2:N_x,2:N_y)  - H_z_n(2:N_x,1:N_y-1) ) ;
    E_y_n(2:N_x,2:N_y) = C_aEy(2:N_x,2:N_y).*E_y_nmin1(2:N_x,2:N_y) ...
        - C_bEy(2:N_x,2:N_y).*(  H_z_n(2:N_x,2:N_y)  - H_z_n(1:N_x-1,2:N_y) ) ;
    
    if not(line_source) 
        % Special update on scat/tot field boundary (only needed for Ey)
        H_z_n_inc = ones(1,N_y)*(Peak/eta_0)*gaussder_norm((m-1/2)*delta_t - (L-1/2)*delta_s/c,m_offset,sigma) ;
        E_y_n(L,2:N_y) = C_aEy(L,2:N_y).*E_y_nmin1(L,2:N_y) ...
            - C_bEy(L,2:N_y).*(  H_z_n(L,2:N_y)  - H_z_n_inc(2:N_y) - H_z_n(L-1,2:N_y) ) ;
    end
    % Impose ABC on sides - assumes free space cell on boundary.
    % Left/right boundaries:
    %E_y_n(1,2:N_y-1)   = E_y_nmin1(1,2:N_y-1)*(1-c*delta_t/delta_s)   + c*delta_t/delta_s*E_y_nmin1(2,2:N_y-1);
    %E_y_n(N_x,2:N_y-1) = E_y_nmin1(N_x,2:N_y-1)*(1-c*delta_t/delta_s) + c*delta_t/delta_s*E_y_nmin1(N_x-1,2:N_y-1);
    % Top/bottom boundaries:
    %E_x_n(2:N_x-1,1)   = E_x_nmin1(2:N_x-1,1)*(1-c*delta_t/delta_s)   + c*delta_t/delta_s*E_x_nmin1(2:N_x-1,2);
    %E_x_n(2:N_x-1,N_y) = E_x_nmin1(2:N_x-1,N_y)*(1-c*delta_t/delta_s) + c*delta_t/delta_s*E_x_nmin1(2:N_x-1,N_y-1);
    
    % Fix outer values of E_tangential as PEC:
    E_y_n(1,:) = 0;
    E_y_n(N_x,:) = 0;
    E_x_n(:,1) = 0;
    E_x_n(:,N_y) = 0;
    
    % Store data
    % Movie
    if mod(m,movie_interval) == 0 
        mesh(eta_0*H_z_n) % Normalize
        title(strcat('\eta_o H_z field at timestep ',num2str(m)))
        H_z_Movie(movie_count) = getframe;
        movie_count = movie_count +1;
    end
    % Time history
    H_z_point1(m) = H_z_n(point1_x,point1_y);
    H_z_point2(m) = H_z_n(point2_x,point2_y);
    E_y_point1(m) = E_y_n(point1_x,point1_y);
    E_y_point2(m) = E_y_n(point2_x,point2_y);
    
    % Update for next iteration
    H_zx_nmin1 = H_zx_n;
    H_zy_nmin1 = H_zy_n;
    E_x_nmin1 = E_x_n;
    E_y_nmin1 = E_y_n;
    
    % Output some indication of how far the code is:
    % disp('.')
    if(rem(m,report_time_interval)==0)
        m
    end 
end
% End of time stepping
%------------------------------------------
disp('CPU time in seconds for time stepping')
run_time = cputime-start_time % seconds
floprate = 11*N_x*N_y*(M-1)/run_time

% movie(H_z_Movie,1,4);

time=[0:M-1]*delta_t;
plot(time/1e-9,E_y_point1)
xlabel('Time [ns]')
ylabel('E_y [V/m]')


print -deps RFGaussDerSimABC
disp('Press any key to continue')
pause;

% Compute and store time histories of source pulse

for mm = 1:M
    t(mm) = delta_t*(mm-1); 
    GaussDerSource(mm) = gaussder_norm(t(mm),m_offset,sigma);
end

delta_f = 1/((M-1)*delta_t);
freq=delta_f*(0:M-1);

clf;
run_movie = input('Run movie? (y/n)','s')    % Movie not always wanted, and difficult to stop. 
if run_movie =='y' | run_movie =='Y'
   movie(H_z_Movie,1,1)
end

% Remove large variables from workspace before saving
clear C_aEx C_bEx C_aEy C_bEy D_aHzx D_bHzx D_aHzy D_bHzy
clear E_x_n E_x_nmin1 E_y_n E_y_nmin1 H_z_n H_z_nmin1 H_zx_n H_zx_nmin1 H_zy_n H_zy_nmin1mesh_pic
clear sigma_x sigma_y sigma_ast_x sigma_ast_y
if run_movie =='y' | run_movie =='Y'
    save PMLMovie H_z_Movie
end 
clear H_z_Movie
  
save cyl_fdtd_data 

